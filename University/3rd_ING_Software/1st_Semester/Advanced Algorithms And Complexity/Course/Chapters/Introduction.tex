

\section{Introduction}
\subsection{Algorithm's Complexity}
\vspace{0.25cm}
\begin{tcolorbox}[enhanced, colback=white!90!greenPlot, colframe=greenPlot!60!black, coltitle=white, fonttitle=\bfseries\Large, title=Definition, boxrule=1mm, arc=0.5mm, drop shadow=greenPlot!35!gray]
It's a study of all the resources needed to execute the program. This can include time, memory, and bandwidth
(if the program sends requests over a network). However, the main focus is often on time, because while memory and
bandwidth can be upgraded with more advanced hardware, time cannot be bought.\end{tcolorbox}

\vspace{0.25cm}
\subsection*{\underline{Example :}}

\begin{algorithm}
\caption{Sum of First N Integers}
\begin{algorithmic}[1]
\State \textbf{\textcolor{redPlot}{Var}}
\State n, sum, i \textcolor{blue}{integer};
\vspace{0.5em}
\State  \textbf{\textcolor{redPlot}{Begin}}
\State sum $\gets$ 0; 
\State  i $\gets$ 1;
\vspace{0.5em}
\State \textcolor{purplePlot!80!black}{print}(\textcolor{blueArea!60!black}{'Input Integer N : '}) 
\State \textcolor{purplePlot!80!black}{Read}(n);
\vspace{0.5em}
\While{i \textcolor{redPlot}{\textbf{\textless=}} n}
\State sum $\gets$ sum \textcolor{redPlot}{ \textbf{+}} i; 
\State i $\gets$ i \textcolor{redPlot}{ \textbf{+}} 1; 
\EndWhile

\vspace{0.5em}
\State \textcolor{purplePlot!80!black}{print}(\textcolor{blueArea!60!black}{'Sum is ' },{sum});
\vspace{0.5em}
\State  \textbf{\textcolor{redPlot}{End}}
\end{algorithmic}
\end{algorithm}


\vspace{0.35cm}

\begin{tcolorbox}[enhanced, colback=white!90!greenPlot, colframe=greenPlot!60!black, coltitle=white, fonttitle=\bfseries\Large, title=Some Terminology, boxrule=1mm, arc=0.5mm, drop shadow=greenPlot!35!gray]
\begin{itemize}
    \item \textbf{Frequency of Execution (\(F_r\))}: The number of times an instruction is executed.
    \item \textbf{Execution Time of Basic Instructions (\(\Delta t\))}: We assume that all basic instructions
(such as print, read, assignment, arithmetic operations, etc.) have the same execution time, denoted as \(\Delta t\).
    \item \textbf{Function (\(f(n)\))}: Represents the total frequency of the program's instructions in relation to the data size \(n\).
    \item \textbf{Execution Time Function (\(T(n)\))}: The execution time function in relation to the data size \(n\).
\end{itemize}
\end{tcolorbox}


\vspace{0.5cm}
\newpage
\subsection*{\underline{Time Complexity :}}
we have \(f(n) = \sum fr\) since \(f(n)\) is sum of frequency of execution (\(fr\)) we need to figure out the
\(fr\) of each instruction and sum them : 

\vspace{0.5cm}
sum $\gets$ 0  \hspace{4.15cm} \(fr = 1\) (one affectation)

\vspace{0.15cm}
i $\gets$ 1  \hspace{4.65cm} \(fr = 1\) (one affectation)

\vspace{0.15cm}
\textcolor{purplePlot!80!black}{print}(\textcolor{blueArea!60!black}{'Input Integer N : '})  \hspace{1.5cm} \(fr = 1\) (one print)

\vspace{0.15cm}
\textcolor{purplePlot!80!black}{Read}(n)  \hspace{4.25cm} \(fr = 1\) (one read)

\vspace{0.15cm}

\textbf{while} i \textcolor{redPlot}{\textbf{\textless=}} n  \textbf{do} \hspace{2.75cm} \(fr = n+1\) (check the while condition n+1 times)

\vspace{0.15cm}
sum $\gets$ sum \textcolor{redPlot}{ \textbf{+}} i \hspace{3cm} \(fr = 2n\) (one affectation and one arithmetic operation + (2) inside a while that loops n times (2n))

\vspace{0.15cm}
i $\gets$ i \textcolor{redPlot}{ \textbf{+}} 1 \hspace{4cm} \(fr = 2n\) (one affectation and one arithmetic operation + (2) inside a while that loops n times (2n))

\vspace{0.15cm}

\textcolor{purplePlot!80!black}{print}(\textcolor{blueArea!60!black}{'Sum is ' },{sum}) \hspace{2.25cm} \(fr = 1\) (one print)

\vspace{0.75cm}
\begin{align*}
f(n) &= \sum fr \\
     &= 1 + 1 + 1 + 1 + (n+1) + 2n + 2n + 1 \\
     &= 5n + 6 \\
     &= \boxed{5n + 6}
\end{align*}

\vspace{0.5cm}
now that we have the complexity function \(f(n)\) we need to find the \(T(n)\)  we have \(T(n) = f(n) \times \Delta t\)

\begin{align*}
T(n) &= f(n) \times \Delta t\\ 
&= (5n + 6) \times \Delta t \\
&= \underbrace{5 \Delta t}_{a} n + \underbrace{\Delta t 6}_{b} \\
&= \boxed{an+b} 
\end{align*}

\vspace{0.35cm}

\begin{tcolorbox}[enhanced, colback=white!90!greenPlot, colframe=greenPlot!60!black, coltitle=white, fonttitle=\bfseries\Large, title=Note, boxrule=1mm, arc=0.5mm, drop shadow=greenPlot!35!gray]
\begin{itemize}
    \item \textbf{Exact Theoritical Complexity} : It's \(T(n)\)
    \item \textbf{Approximate Theoretical Complexity (Asymptotic)}: 
It approximates \(T(n)\) by omitting all constants and taking the term with the highest growth rate.
\end{itemize}
\end{tcolorbox}


\vspace{0.75cm}
In this example the exact theoritical complexity is \(T(n) = an+b\) and its approximate theoritical complexity is 
\(an+b \sim O(n)\) we notice that its time complexity is linear 

\begin{center}
    \begin{tikzpicture}
           \begin{axis}[
        height = 9.5cm,
        width = 10cm,
        axis lines = middle,           % Ensures axes cross at (0, 0)
        xlabel=$n$, 
        ylabel=$time$, 
        xmin = 0, xmax = 100,           % Set x-axis range
        ymin = 0, ymax = 500,           % Set y-axis range
       ytick={0,50,...,500},             % Y-tick values
        xtick={0,25,...,100},
    ]\addplot[domain = 0:100,samples=200, blue] {5*x + 6};
 \draw[dashed, red] (axis cs:50,0) -- (axis cs:50,256)-- (axis cs:0,256);
 \draw[dashed, red] (axis cs:25,0) -- (axis cs:25,131)-- (axis cs:0,131);     
 \draw[dashed, red] (axis cs:75,0) -- (axis cs:75,381)-- (axis cs:0,381);     
\end{axis}
    \end{tikzpicture}
\end{center}
\subsection*{\underline{Space Complexity :}}
Before a program gets executed all instructions are loaded in memory and at execution time all variables are also stored
in the memory so we need to find the number of instruction and number of variables and sum them let's suppose they all take same size 1 Byte

\vspace{0.15cm}
We have in the algorithm a total of 3 variables and 8 instructions in 3+8 = 11 Byte it's constant \(\sim O(1)\)
