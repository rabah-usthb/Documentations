\section{Conception}

\subsection{Introduction}
\begin{prettyBox}{Conception Introduction}{mypur}
Conception represents the solution to a problem, expressed through structured diagrams such as UML.
Creating a conception is an iterative process that requires significant time and creativity.
Initially, a solution is developed, and subsequent iterations focus on optimizing it.

\vspace{0.15cm}
Each iteration refines and expands the conception until reaching a final result that is easy to
maintain. This ensures better implementation, facilitates adding or removing features, and 
simplifies bug fixes.

\end{prettyBox}

\vspace{0.5cm}
\begin{prettyBox}{Difference Between Conception \& UML}{red} 
    \begin{center} 
        \textbf{Conception $\not\Leftrightarrow$ UML} 
     \end{center}
UML is merely a tool used to represent the conception, it is not the conception itself. 
Conception encompasses more than just diagramsâ€”it includes algorithms, explanations of 
diagrams, and other documents.
\end{prettyBox}


\vspace{0.5cm}
\begin{prettyBox}{Importance of Maintainability}{red} 
Easy maintainability is one of the key qualities of a good conception and arguably the most
important criteria. This is because we want the software to be long-lasting, and effective 
maintenance is essential to achieving that.
\end{prettyBox}

\vspace{0.5cm}
\subsection{Itterative Process Of Conception}

\begin{prettyBox}{Global \& Detailed Conception}{mypur}
    \begin{itemize}
        \item \textbf{Globale Conception :} Modules must be identified (some modules can 
be divided into sub-modules) , and interaction between modules must be defined
        \item \textbf{Detailed Conception :} Each module must be defined independently in detail.
    \end{itemize}
The conception should have high ratio of cohesion and low ratio of coupling
\end{prettyBox}

\vspace{0.5cm}

\begin{prettyBox}{Why Global Conception Then Detailed Conception}{red} 
    We first define the high-level structure of the modules and their interactions to provide an overall system architecture.
    This gives a clear overview of the software before delving into the detailed characteristics of each module.
\end{prettyBox}

\vspace{0.5cm}


\begin{prettyBox}{Why High Cohesion \& Low Coupling}{red}
    \begin{itemize}
        \item \textbf{Cohesion}: How related the responsibilities of a module are.
            \begin{itemize}
                \item \textbf{High Cohesion}: The module has a clear, well-defined responsibility, making it easier to understand, maintain, and modify.
                \item \textbf{Low Cohesion}: The module handles multiple, unrelated responsibilities, making it harder to maintain and understand.
            \end{itemize}
        \item \textbf{Coupling}: How dependent the modules are on each other.
            \begin{itemize}
                \item \textbf{High Coupling}: Modules are highly dependent on each other. A failure in one critical module may cause the entire system to fail.
                \item \textbf{Low Coupling}: Modules are loosely connected, and changes or failures in one module are less likely to impact the others.
            \end{itemize}
    \end{itemize}
    
    \textbf{Why We Want High Cohesion and Low Coupling}:
    \begin{itemize}
        \item \textbf{High Cohesion}: Ensures that each module has a clear, understandable purpose, making the system easier to maintain and extend.
        \item \textbf{Low Coupling}: Reduces dependencies between modules, minimizing the risk of widespread system failure and increasing flexibility.
    \end{itemize}
\end{prettyBox}


\vspace{0.5cm}

\subsection{Classification Of Conception Method}

\vspace{0.25cm}
\subsubsection{Function Oriented Conception}

\vspace{0.25cm}
\begin{prettyBox}{Function-Oriented}{mypur}
    The software is structured using a functional paradigm. It is divided into a set of functions 
that interact with each other. The software is viewed as a complex main function that is 
progressively decomposed into smaller, less complex sub-functions. This process continues until
we reach a detailed conception.

    \vspace{0.15cm}
    Each function has its own local state (local variables), while the software has
a global state (global variables) that is shared among all functions.
\end{prettyBox}

\vspace{0.5cm}
\subsubsection{Object Oriented Conception}

\vspace{0.25cm}

\begin{prettyBox}{Object-Oriented Design}{mypur}
    The software is viewed as a collection of encapsulated and independent objects. 
These objects communicate with each other by sending messages (method calls).

    \vspace{0.15cm}
    Each object is identified by its name and encapsulated attributes (variables and methods).
\end{prettyBox}


\vspace{0.5cm}

\subsubsection{Data Oriented Conception}

\vspace{0.25cm}

\begin{prettyBox}{Data-Oriented}{mypur}
    The software's structure must reflect the structure of the data it traits .
    Therefore the conception is influenced by the ouput input data.
\end{prettyBox}

\vspace{1cm}

\subsection{Conception's Principales}To make sure the conception ensures an easily maintainable
software we must follow some printcipales :


\begin{prettyBox}{Principles}{mypur}

\begin{itemize}
    \item \textbf{Abstraction:} Focuses on the essential characteristics while
hiding unnecessary details.
    \item \textbf{Modularity:} Divides the system into modules with well-defined interactions,
adhering to the principle of high cohesion and low coupling.
    \item \textbf{Encapsulation:} Hides internal details of a module from other modules.
    \item \textbf{Structuring:} Ensures a structured conceptions (levels) , we can at least have general \& detailed conception.
\end{itemize}

\end{prettyBox}

\vspace{0.5cm}

\subsection{Notation For Fonctional Conception}


\begin{prettyBox}{Notation}{mypur}
\begin{itemize}
    \item \textbf{Data Flow Diagram (DFD):} Shows how data is transformed and passed from one module to another.
    \item \textbf{Structure Diagram (SD):} A hierarchical diagram that illustrates the structured relationships between the components of the software.
\end{itemize}
\end{prettyBox}


\vspace{0.5cm}

\begin{prettyBox}{Relation Between DFD \& SD}{red}
    DFD and SD are complementary to each other, working together to clearly describe the functional design of a software system.
\end{prettyBox}

\vspace{0.5cm}

\subsubsection{DFD}

\vspace{0.25cm}

\begin{prettyBox}{DFD}{mypur}
    A DFD diagram consists of four components:
    \begin{itemize}
        \item \textbf{Transformations}: Represented as circles.
        \item \textbf{Data}: Represented as axis.
        \item \textbf{Logical AND}: Represented by the symbol *.
        \item \textbf{Logical OR}: Represented by the symbol +.
    \end{itemize}
\end{prettyBox}

\vspace{0.5cm}

\begin{center}
    \begin{tikzpicture}
        \draw[->] (0,0) -- (2,0);
        \node at (1,0.25){D$_{1}$};
        \draw (2.5,0) circle (0.5);
        \node at (2.5,0) {T$_{1}$};
        
        \draw[->] (3,0) -- (5,0);
        \node at (4,0.25){D$_{1.1}$};
        \draw (5.5,0) circle (0.5);
        \node at (5.5,0) {T$_{2}$};

        \draw[->] (6,0) -- (8.25,-0.35);
        \node at (7,0.15){D$_{1.2}$};
        \draw (8.5,-0.75) circle (0.5);
        \node at (8.5,-0.75) {T$_{3}$};
        
        \draw[->] (6,-0.85) -- (8,-0.85);
        \draw[->] (9,-0.75) -- (11,-0.75);
        \node at (7.5,-0.65) {*};
        \node at (7,-1.25) {D$_{2}$};
        \node at (10,-0.5) {D$_{3}$};
        \draw (11.5,-0.75) circle (0.5);
        \node at (11.55,-0.75) {T$_{4}$};
        \draw[->] (11.25,-1.2) -- (10,-2);

        \node at (11.5,-1.5) {+};
        \draw[->] (11.75,-1.2) -- (13,-2);

        \node at (13,-1.5) {D$_{3.2}$};

        \node at (10,-1.5) {D$_{3.1}$};

    \end{tikzpicture}
\end{center}

\vspace{0.5cm}

\begin{prettyBox}{Note}{red}
    A DFD specifies the operations without detailing how they are performed. Each node in the diagram can be further described with another DFD, allowing for a hierarchical decomposition of processes.
\end{prettyBox}

\vspace{0.5cm}

\subsection*{\underline{Example :}}
A Software that processes a text document by splitting it into individual
words. It then checks each word against a dictionary. If the word exists in
the dictionary, it is marked as correct. Otherwise, the software notifies the
user and allows them to decide whether the word is valid. If the user 
identifies the word as incorrect, it is added to the list of misspelled words.
If the user confirms the word is valid, it is added to the dictionary.

\begin{center}
\includegraphics[width=0.9\textwidth]{Chapters/Diagram/DFD/dfd2.drawio.pdf}
\end{center}

\subsubsection{SD}

\begin{prettyBox}{SD}{mypur}
A structure diagram is a hierarchical representation of a system in the
form of a tree. It illustrates how the transformation elements of a Data Flow
Diagram (DFD) can be implemented within the hierarchical units of software architecture.
\end{prettyBox}

\vspace{0.25cm}

\begin{prettyBox}{Difference Between SD \& DFD}{red}
They might seem similar but they serve different purposes and compliment each other ,
SD shows how the data changes and flows with the transformation , and DFD focuses on the hiertachy
of the software architecture
\end{prettyBox}

\subsubsection*{Symboles}

\begin{center}
\includegraphics[width=0.9\textwidth]{Chapters/Diagram/SD/smb.drawio.pdf}
\end{center}

\vspace{0.5cm}

\subsubsection*{Tree Nodes}
\begin{itemize}
    \item \textbf{Synchronisation Unit} : The root node at the top represent the the global idea of the software 
    \item \textbf{Transformation Unit} : The parent node has to point to at least one other units , represent a function of the software
    \item \textbf{Input/Output Unit} : The leaf node same as parent node just never points to another unit
\end{itemize}

\vspace{0.5cm}

\begin{prettyBox}{Note}{red}
\textbf{\underline{Synchronisation Unit's Role}}\\[0.15cm]
The synchronisation unit (root node) never creates the data it only pass it to other units.\\[0.25cm]
\textbf{\underline{No Link Between Unit Of Same Level}}\\[0.15cm]
There can be link between units with simple arrow only with units of different level.\\[0.25cm]
\textbf{\underline{SD Level}}\\[0.15cm]
It's the number of levels beside the root node (don't count the synchronisation unit).
\end{prettyBox}

\begin{center}
\includegraphics[width=0.85\textwidth]{Chapters/Diagram/SD/sd1.drawio.pdf}
\end{center}

\vspace{0.25cm}

\subsection*{\underline{Example :}}
We will take same example of word checker, we will make level 1 SD then level 2 SD

\subsection*{\underline{Level 1 SD :}}
\begin{center}
\includegraphics[width=0.85\textwidth]{Chapters/Diagram/SD/sd2.drawio.pdf}
\end{center}



\subsection*{\underline{Level 2 SD :}}
\begin{center}
\includegraphics[width=0.8\textwidth]{Chapters/Diagram/SD/sd3.drawio.pdf}
\end{center}

\vspace{1cm}
\subsubsection{Sequence Diagram}


\begin{prettyBox}{Sequence Diagram}{mypur}
A sequence diagram illustrates the dynamic behavior of a system over time (notion of time). 
It visualizes the messages exchanged between objects/actors and is read from top to bottom.
\end{prettyBox}

\subsection*{\underline{Symboles :}}

\begin{center}
\includegraphics[width=0.8\textwidth]{Chapters/Diagram/SQD/sym.drawio.pdf}
\end{center}


\subsection*{\underline{Example :}}

\vspace{0.25cm}
\begin{center}
\includegraphics[width=0.95\textwidth]{Chapters/Diagram/SQD/sqd.drawio.pdf}
\end{center}


\vspace{1cm}
\subsubsection{State-Transition Diagram}

\begin{prettyBox}{State Diagram}{mypur}
A state diagram illustrates how the state of an object changes in response to events.
\end{prettyBox}

\subsection*{\underline{Symboles :}}

\begin{center}
\includegraphics[width=0.8\textwidth]{Chapters/Diagram/ST/sym.drawio.pdf}
\end{center}

\vspace{0.25cm}

\begin{prettyBox}{Note}{red}
We can have only \textbf{one initial state} , but we can have \textbf{many final state}.
\end{prettyBox}

\subsection*{\underline{Example :}}

\begin{center}
\includegraphics[width=0.95\textwidth]{Chapters/Diagram/ST/state.drawio.pdf}
\end{center}


\vspace{1cm}
\subsubsection{Activity Diagram}

\begin{prettyBox}{Activity Diagram}{mypur}
An activity diagram describes the progression of activities within the system and outlines the logical flow of processes.
\end{prettyBox}

\subsection*{\underline{Symboles :}}

\begin{center}
\includegraphics[width=0.715\textwidth,height=0.9\textheight]{Chapters/Diagram/AC/sym.drawio.pdf}
\end{center}


\subsection*{\underline{Example :}}

\vspace{1cm}

\begin{center}
\includegraphics[width=0.55\textwidth,height=0.6\textheight]{Chapters/Diagram/AC/ac1.drawio.pdf}
\end{center}

\begin{center}
\includegraphics[width=0.95\textwidth,height=0.65\textheight]{Chapters/Diagram/AC/ac2.drawio.pdf}
\end{center}



\vspace{0.25cm}

\begin{prettyBox}{Note}{red}
\begin{itemize}
    \item We can have only \textbf{one begin} , but we can have \textbf{end}.
    \item Even though activity diagram has the notion of state it focuses more on the 
    logical flow of activities of the system.
\end{itemize}
\end{prettyBox}


\subsubsection{Design Pattern}

\begin{prettyBox}{Definition}{mypur}
A design pattern describes \textbf{proven} and \textbf{abstract} solutions  
to \textbf{recurring} problems in software design.
\end{prettyBox}


\vspace{0.25cm}
\begin{prettyBox}{Why Proven}{red}
Proven solutions have been tested on real projects, ensuring reliability and effectiveness.
\end{prettyBox}

\vspace{0.25cm}
\begin{prettyBox}{Why Abstract}{red}
Abstract solutions can be adapted and customized to meet specific needs.
\end{prettyBox}

\vspace{0.25cm}
\begin{prettyBox}{Why Recurring}{red}
We want model for recurring problems to address patterns in design problems that repeat across different contexts.
\end{prettyBox}

\vspace{0.25cm}

\begin{prettyBox}{History}{mypur}
The concept of design patterns was first introduced by Christopher Alexander
in the field of architecture. It was later adapted to the field of computer
science in 1977.
\end{prettyBox}

\vspace{0.25cm}
\subsection*{\underline{Categories :}}
The first influential book on design patterns, \textbf{Design Patterns: Elements of Reusable
Object-Oriented Software} by the "Gang of Four" (Erich Gamma, Richard Helm,
Ralph Johnson, and John Vlissides), was published in its second edition in 1995.
It presents a collection of 23 design patterns, classified into three categories.


\vspace{0.75cm}

\begin{prettyBox}{Creational Design Pattern}{mypur}
Addresses issues related to object creation and configuration, such as the Singleton pattern.
\end{prettyBox}

\vspace{0.25cm}
\begin{prettyBox}{Structural Design Pattern}{mypur}
Describes how to structure classes like: The Composite Pattern
\end{prettyBox}


\vspace{0.25cm}

\begin{prettyBox}{Behavioral Design Pattern}{mypur}
Focuses on the interaction and communication between objects to define
the behavior of an application, such as the Observer pattern.
\end{prettyBox}


\vspace{0.25cm}
\begin{prettyBox}{Note}{red}
The design patterns from the "Gang of Four" are intended for
object-oriented design.
\end{prettyBox}

\vspace{0.25cm}

\subsection*{\underline{Pros:}}
\begin{itemize}
    \item Solves recurring problems with proven and reliable solutions.
    \item Improves quality and speed.
    \item Design patterns provide a common language for communication between designers.
    \item Design patterns are independent of implementation languages and sufficiently generic (abstract) to be applied in various situations.
\end{itemize}

\vspace{0.25cm}

\subsection*{\underline{Cons:}}
\begin{itemize}
    \item Design patterns need to be mastered and thoroughly studied.
    \item Design patterns always require adaptation when applied.
    \item Design patterns can increase the complexity of simple solutions.
\end{itemize}

\newpage
\subsection*{\underline{Some Design Pattern:}}

\subsection*{\underline{Singleton:}}
Singleton is a creational design pattern that aims to limit the instanciation
of the a class to only one object and give global acess to it.

\begin{center}
\includegraphics[width=0.55\textwidth,height=0.3\textheight]{Chapters/DesignPattern/Singleton/single.drawio.pdf}
\end{center}

\begin{prettyBox}{Explication}{mypur}
We first initialize a static private attribut called instance to null , when ever we want to get instance of singleton
we call the public static method getInstance that checks if instance is null if yes it will call the private constructor
and in either case it returns the instance 
\end{prettyBox}

\vspace{0.25cm}
\subsubsection*{\underline{Java Code:}}

\lstinputlisting[style=javastyle]{Chapters/DesignPattern/Singleton/S1/Singleton.java}

\newpage
\lstinputlisting[style=javastyle]{Chapters/DesignPattern/Singleton/S1/Main.java}


\subsubsection*{\underline{Output:}}
\begin{lstlisting}[style=cmd]
Instance Of Singleton
\end{lstlisting}

\subsubsection*{\underline{Example:}}
\begin{center}
\includegraphics[width=0.45\textwidth,height=0.35\textheight]{Chapters/DesignPattern/Singleton/single2.drawio.pdf}
\end{center}


\subsubsection*{\underline{Java Code:}}
\lstinputlisting[style=javastyle]{Chapters/DesignPattern/Singleton/S2/Main.java}

\newpage
\lstinputlisting[style=javastyle,basicstyle=\scriptsize\ttfamily]{Chapters/DesignPattern/Singleton/S2/dataBaseManager.java}


\newpage
\subsubsection*{\underline{Output:}}
\begin{lstlisting}[style=cmd]
dataBaseManager Initialized
system/1234//localhost:1521/XE
Dbaiot/psw//localhost:1521/XE
Already Initialized
\end{lstlisting}

\vspace{0.5cm}
\subsection*{\underline{Composite:}}
The Composite pattern is a structural design pattern that imposes a
hierarchical tree structure, consisting of simple elements and composite elements.

\begin{center}
\includegraphics[width=0.55\textwidth,height=0.35\textheight]{Chapters/DesignPattern/Composite/comp1.drawio.pdf}
\end{center}


\begin{prettyBox}{Explication}{mypur}
The Element class serves as an abstract parent class with an unimplemented method, operation().  
The Leaf class inherits from Element and overrides the operation() method to provide its specific implementation.  
Similarly, the Composite class also inherits from Element and implements operation(). However, it has an attribute that is a collection of Element objects.  
This design allows the collection to hold both simple elements (Leaf) and complex elements (Composite), organizing them into a tree structure.
\end{prettyBox}

\vspace{0.25cm}
\begin{prettyBox}{Note}{red}
Element can be an abstract class or an interface both implementations are valid.
\end{prettyBox}

\vspace{0.25cm}
\subsubsection*{\underline{Java Code:}}

\lstinputlisting[style=javastyle]{Chapters/DesignPattern/Composite/C1/Element.java}

\lstinputlisting[style=javastyle]{Chapters/DesignPattern/Composite/C1/Leaf.java}

\lstinputlisting[style=javastyle]{Chapters/DesignPattern/Composite/C1/Composite.java}

\lstinputlisting[style=javastyle]{Chapters/DesignPattern/Composite/C1/Main.java}


\subsubsection*{\underline{Output:}}
\begin{lstlisting}[style=cmd]
Leaf Operation
Leaf Operation
Composite Operation


Leaf
Leaf

 Composite
  Leaf
   Composite
    Leaf
    Leaf
\end{lstlisting}


\subsubsection*{\underline{Graphical Representation Of The Composite}}

\vspace{0.25cm}
\begin{center}
\includegraphics[width=0.55\textwidth,height=0.4\textheight]{Chapters/DesignPattern/Composite/tree.drawio.pdf}
\end{center}



\vspace{0.25cm}
\subsubsection*{\underline{Example:}}
\begin{center}
\includegraphics[width=0.55\textwidth,height=0.4\textheight]{Chapters/DesignPattern/Composite/comp2.drawio.pdf}
\end{center}

\newpage
\subsubsection*{\underline{Java Code:}}
\lstinputlisting[style=javastyle]{Chapters/DesignPattern/Composite/C2/GeoForm.java}
\lstinputlisting[style=javastyle]{Chapters/DesignPattern/Composite/C2/simpleForm.java}
\lstinputlisting[style=javastyle]{Chapters/DesignPattern/Composite/C2/formType.java}
\newpage
\lstinputlisting[style=javastyle]{Chapters/DesignPattern/Composite/C2/complexForm.java}
\newpage
\lstinputlisting[style=javastyle]{Chapters/DesignPattern/Composite/C2/Main.java}

\subsubsection*{\underline{Output:}}
\begin{lstlisting}[style=cmd]
Draw LINE
Draw TRIANGLE
Draw Complexe Form


LINE
TRIANGLE
 Complex
  SQUARE
  CIRCLE
   Complex
    LINE
    LINE
\end{lstlisting}

\vspace{0.5cm}

\subsection*{\underline{Observer:}}
The Observer pattern is a behavioral design pattern.It monitors
the state of a subject object, and when the state changes, the subject 
notifies the observers, which then update accordingly.

\vspace{0.25cm}
\begin{center}
\includegraphics[width=0.55\textwidth,height=0.35\textheight]{Chapters/DesignPattern/Observer/obs1.drawio.pdf}
\end{center}

\vspace{0.25cm}
\begin{prettyBox}{Explication}{mypur}
The Observer is an abstract class that defines an unimplemented method, update(state), which is executed each time the state changes.  
The Subject is also an abstract class. It holds a collection of observers and defines unimplemented methods: add(observer), delete(observer), and notify(). The notify() 
method calls the update method of each observer when the state changes.  
A ConcreteObserver inherits from Observer and implements the update method.  
A ConcreteSubject inherits from Subject, overrides all unimplemented methods, and includes a state attribute with its getter and setter.  
Whenever the setter is called, the notify() method is invoked within its body to ensure all observers are updated.
\end{prettyBox}

\vspace{0.25cm}
\begin{prettyBox}{Note}{red}
Subject and Observer can be an abstract class or an interface both implementations are valid.
\end{prettyBox}

\newpage
\subsubsection*{\underline{Java Code:}}

\lstinputlisting[style=javastyle]{Chapters/DesignPattern/Observer/O1/Observer.java}

\vspace{0.25cm}
\lstinputlisting[style=javastyle]{Chapters/DesignPattern/Observer/O1/Subject.java}

\vspace{0.25cm}
\lstinputlisting[style=javastyle]{Chapters/DesignPattern/Observer/O1/concretObserver.java}
\newpage
\lstinputlisting[style=javastyle]{Chapters/DesignPattern/Observer/O1/concretSubject.java}

\vspace{0.5cm}
\lstinputlisting[style=javastyle]{Chapters/DesignPattern/Observer/O1/Main.java}
\newpage

\subsubsection*{\underline{Output:}}
\begin{lstlisting}[style=cmd]
Setting state to State 1
Observer Alice New State : State 1
Observer Bob New State : State 1
Setting state to State 2
Observer Bob New State : State 2
\end{lstlisting}
\vspace{0.5cm}

\vspace{0.25cm}
\subsubsection*{\underline{Example:}}

\vspace{0.25cm}
\begin{center}
\includegraphics[width=0.55\textwidth,height=0.4\textheight]{Chapters/DesignPattern/Observer/obs2.drawio.pdf}
\end{center}

\newpage
\subsubsection*{\underline{Java Code:}}
\lstinputlisting[style=javastyle]{Chapters/DesignPattern/Observer/O2/Student.java}

\vspace{0.25cm}
\lstinputlisting[style=javastyle]{Chapters/DesignPattern/Observer/O2/Teacher.java}

\vspace{0.25cm}
\lstinputlisting[style=javastyle]{Chapters/DesignPattern/Observer/O2/concretStudent.java}
\newpage
\lstinputlisting[style=javastyle]{Chapters/DesignPattern/Observer/O2/concretTeacher.java}

\vspace{0.5cm}
\lstinputlisting[style=javastyle]{Chapters/DesignPattern/Observer/O2/Main.java}

\newpage

\subsubsection*{\underline{Output:}}
\begin{lstlisting}[style=cmd]
Setting Activity To DW 2 EX1
Student Zaki changed activity to DW 2 EX1
Student Rabah changed activity to DW 2 EX1
Setting Activity To LAB2
Student Zaki changed activity to LAB2
\end{lstlisting}

